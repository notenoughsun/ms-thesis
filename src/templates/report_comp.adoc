:notitle:
// :author: Чикичев Тимур Вадимович
:email: timur7002007@gmail.com
:source-highlighter: pygments
:pygments-style: emacs
:stem: latexmath

:toc-title: Содержание отчета
:imagesdir_old: {imagesdir}

:task_type: Домашнее задание
:controller: Берчун Юрий Валерьевич
:cource_name: Задача компоновки
// :var_num: 19
:titul_dir: ../src


<<<

=== Задание

.Задача компоновки
Дана матрица смежности некоторого графа.
Необходимо найти оптимальный вариант разбиения
множества вершин графа на подмножества так,
чтобы минимальное количество связей,
соединяющих вершины этого графа, потерпели разрыв.

=== Алгоритм работы программы

Дана матрица смежности размером 30*30

Генерируется варианты разбиения множества вершин графа на подмножества по заданному условию (разбиения по 5/6/7 элементов).

Для каждого из разбиений программа реализует алгоритм, выбирающий в группы на каждой итерации оптимизации вершины меньшим итоговым количеством внешних связей.


=== Подготовительный этап

На подготовительном этапе для выбранной вершины и
выбранного разбиения генерируются группы вершин.

К первой выбранной вершине в группу добавляются все смежные с ней вершины, если в текущем разбиении требуется больше элементов, то выбирается следующая вершина из добавленных и процесс добавления повторяется.

Если у текущих выбранных вершин нет соседних вершин, а в группа еще не заполнена то добавляется первая вершина из еще не добавленных.

Процесс повторяется пока не будет набрано требуемое или большее число вершин.

Если набрано число вершин больше чем размер группы то производится оценка количества внешних связей для элементов группы и исключаются менее связные.

В итоге получается одна группа разбиения. Подобным образом заполняются все остальные группы.

.Листинг 1 (Подготовительный этап)
// ----
// include::src/list1.log[]
// ----
----
include::log1/log1.log[]
----

<<<
=== Итерационный этап

.Листинг 2 (Итерационный этап)
----
include::log1/log1.log[]
----
//
// ----
// include::src/list2.log[]
// ----

Для заполненных подмножеств подсчитываются перестановочные коэффициенты. Они соответствуют количеству разрываемых и добавляемых связей при перестановке вершин из группы в группу.

Для каждого из подмножеств высчитывается количество внутренних и внешних(разорванных) связей.

Если получается коээфиициент больше нуля, то это означает что замене вершин из двух групп получится лучшее решение.
Производится замена вершин и продолжениие решения.

В результате для текущего разбиения получается компоновка вершин с наименьшим числом внешних связей. Далее выбирается решение с минимальным числом внешних связей.

// , которое имеет наибольшее количество внутренних связей в графе, а соответственно наименьшее количество разорванных.

<<<
=== Программная реализация

Использован алгоритм Гинденбурга для перебора всех вариантов разбиения множества вершин графа на заданное количество подмножеств.

Далее выбираются варианты разбиений по 5,6,7 элементов

----
separation_list = [
     [5, 5, 6, 7, 7],
     [5, 6, 6, 6, 7],
     [6, 6, 6, 6, 6],
     [5, 5, 5, 5, 5, 5]
 ]
----

=== Результат работы программы

Полученные результаты для вариантов разбиения
----
[[7, 7, 6, 5, 5], 392]
[[7, 6, 6, 6, 5], 390]
[[6, 6, 6, 6, 6], 388]
[[5, 5, 5, 5, 5, 5], 322]
----


// .Листинг 4 (Алгоритм Гинденбурга)
// ----
// include::src/list4.log[]
// ----

// .pr14_2_ginden
// [source,c]
// --------------------------------------
// include::pr14_2_ginden.py[]
// --------------------------------------

// .Листинг 3 (Метод двоичного счета)
// ----
// include::src/list3.log[]
// ----

Далее приведен полный код программы, алгоритм работы которой описан в предыдущем разделе

// ==== Листинг (Полный код программы)
.comp_main
[source,c]
--------------------------------------
include::comp_main.py[]
--------------------------------------

.vertex
[source,c]
--------------------------------------
include::vertex.py[]
--------------------------------------

.packing
[source,c]
--------------------------------------
include::packing_.py[]
--------------------------------------

// .input_data
// [source,c]
// --------------------------------------
// include::input_data.py[]
// --------------------------------------

//
// .pr14_2_ginden
// [source,c]
// --------------------------------------
// include::pr14_2_ginden.py[]
// --------------------------------------


//
// [6, 6, 6, 6, 6], [5, 6, 6, 6, 7], [5, 5, 6, 7, 7], [5, 5, 5, 5, 5, 5] оптимальными являются [5, 6, 6, 6, 7] и [5, 5, 6, 7, 7]. В данном случае программа выбирает первое из предложенных разбиений в качестве оптимального. Полный результат работы программы описан в листинге 6.
